# Snapshot testing for Python

[![PyPI](https://img.shields.io/pypi/v/snapshot-testing?label=snapshot-testing)](https://pypi.org/project/ordeq/)
[![PyPI - Downloads](https://img.shields.io/pypi/dm/snapshot-testing?label=downloads)](https://pypistats.org/packages/snapshot-testing)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![ruff](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/astral-sh/ruff/main/assets/badge/v2.json)](https://github.com/astral-sh/ruff)
[![ty](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/astral-sh/ty/main/assets/badge/v0.json)](https://github.com/astral-sh/ty)

This repository contains tools for snapshot testing of Python projects, built on `pytest`.
Snapshot testing captures the output of your project and compares it against a stored "snapshot".

To install this package from PyPI, run:

```bash
uv pip install snapshot-testing
```

## Quickstart
Snapshot tests are defined using the `@snapshot` decorator. 
Here is a simple example:

```python
# tests/test_example.py
from snapshot_testing import snapshot

def func() -> str:
    return "Hello, world!"

@snapshot
def test_func() -> None:
    result = func()
    print(result)
```

That's right, no assertions needed!
When the test `test_func` is run, it will create a snapshot file storing the output of `func()`:

```text
# snapshots/test_example/test_func.snap
Hello, world!
```

When the test is run again, the output will be compared against the stored snapshot.
If the output has changed, the test will fail.

For example, if we modify `func` to return a different string:

```python
def func() -> str:
    return "Hello, universe!"
```

Running the test again will result in a failure.

Instead of writing the assertions, you can update the snapshot to reflect the desired behaviour.
Once you are happy, commit the updated snapshot file to version control.

### Logging, warnings & exceptions
The snapshot will reflect any logging output, warnings, or exceptions raised during the test execution.
For example:

```python
import logging
import warnings
from snapshot_testing import snapshot

logging.basicConfig(level=logging.INFO)

@snapshot
def test_outs() -> None:
    logging.info("This is an info message.")
    warnings.warn("This is a warning message.")
    raise ValueError("This is an exception.")
```

Will produce a snapshot like:

```text
INFO:root:This is an info message.
UserWarning: This is a warning message.
Traceback (most recent call last):
  File "/path/to/test_file.py", line 10, in test_outs
    raise ValueError("This is an exception.")
ValueError: This is an exception.
```

## Introduction to snapshot testing
Snapshot testing is particularly useful for complex outputs where writing assertions would be cumbersome.
It allows you to quickly capture the expected output and focus on changes over time.

## Comparison to existing packages
This package aims to provide a simple snapshot testing solution that requires minimal setup and reduces the time to develop tests.
This is achieved by capturing the output during test execution.
Existing packages, such as `pytest-snapshot` and `pytest-insta`, still require users to write asserts.

## Considerations
Since the snapshots generated by this package capture all output, including logs and exceptions tests should not print sensitive information.
Test output should also be deterministic in order to be reproducible.
Timestamps, memory addresses, or other non-deterministic/unordered objects need to be normalized before printed.


[pytest]: https://docs.pytest.org/en/stable/